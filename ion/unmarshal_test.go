// Copyright (C) 2022 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package ion

import (
	"fmt"
	"math"
	"reflect"
	"testing"

	"github.com/SnellerInc/sneller/date"
)

func TestReadInt(t *testing.T) {
	ints := []int64{
		math.MinInt64,
		-1025, -1024, -1023,
		-1, 0, 1,
		65534, 65535, 65536,
		math.MaxInt64,
	}
	var buf Buffer
	for _, i := range ints {
		buf.Reset()
		buf.WriteInt(i)
		val, rest, err := ReadInt(buf.Bytes())
		if err != nil {
			t.Fatal(err)
		}
		if len(rest) > 0 {
			t.Errorf("case i=%d %d bytes left over", i, len(rest))
		}
		if val != i {
			t.Errorf("%d in -> %d out", i, val)
		}
	}
}

func TestReadIntMagnitudeFromValidIon(t *testing.T) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20}},
		{255, []byte{0x21, 0xff}},
		{65535, []byte{0x22, 0xff, 0xff}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{1, []byte{0x21, 0x01}},
		{257, []byte{0x22, 0x01, 0x01}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1, []byte{0x21, 0x01}},
		{258, []byte{0x22, 0x01, 0x02}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
		{127, []byte{0x21, 0x7f}},
		{32639, []byte{0x22, 0x7f, 0x7f}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
	}

	for _, input := range testcases {
		val, tail, err := ReadIntMagnitude(input.encoded)
		if err != nil {
			t.Errorf("input % 02x: unexpected error %v", input.encoded, err)
		}
		if len(tail) != 0 {
			t.Errorf("input % 02x: the whole input should be consumed but % 02x left", input.encoded, tail)
		}
		if val != input.value {
			t.Errorf("input % 02x: expected value %d, got %d", input.encoded, input.value, val)
		}
	}
}

func TestReadIntMagnitudeFromValidIonWithExtraPaddingAfterValues(t *testing.T) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{255, []byte{0x21, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65535, []byte{0x22, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{257, []byte{0x22, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{258, []byte{0x22, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{127, []byte{0x21, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{32639, []byte{0x22, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	}

	for _, input := range testcases {
		val, tail, err := ReadIntMagnitude(input.encoded)
		if err != nil {
			t.Errorf("input % 02x: unexpected error %v", input.encoded, err)
		}
		if len(tail) != 8 {
			t.Errorf("input % 02x: the input should be consumed and 8-byte tail be returned but % 02x left", input.encoded, tail)
		}
		if val != input.value {
			t.Errorf("input % 02x: expected value %d, got %d", input.encoded, input.value, val)
		}
	}
}

func TestReadIntMagnitudeDetectsInvalidIon(t *testing.T) {
	testcases := []struct {
		encoded []byte
		errmsg  string
	}{
		{[]byte{0x50}, "ion.ReadIntMagnitude: found type decimal, wanted an integer type"},
		{[]byte{0x21}, "invalid TLV encoding bytes"}, // truncated
		{[]byte{0x2e, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			"integer of 10 bytes out of range"},
	}

	for _, input := range testcases {
		_, _, err := ReadIntMagnitude(input.encoded)
		if err == nil {
			t.Errorf("input % 02x: expected error to be returned", input.encoded)
			continue
		}

		if err.Error() != input.errmsg {
			t.Errorf("input % 02x: expected error message %s, got %s",
				input.encoded, input.errmsg, err.Error())
		}
	}
}

func TestUnmarshal(t *testing.T) {

	type recur struct {
		Self int    `ion:"self"`
		Rest *recur `ion:"recur"`
	}

	tcs := []struct {
		in  func(st *Symtab, dst *Buffer)
		out any
	}{
		{
			in: func(st *Symtab, dst *Buffer) {
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("foo"))
				dst.WriteString("foo")
				dst.BeginField(st.Intern("bar"))
				dst.WriteFloat64(100.0) // will convert to int successfully
				dst.BeginField(st.Intern("AlsoIgnored"))
				dst.WriteString("ignore me")
				dst.EndStruct()
			},
			out: struct {
				Foo         string `ion:"foo"`
				Bar         int    `ion:"bar,omitempty"`
				ignored     int
				AlsoIgnored string `ion:"-"`
			}{
				Foo: "foo",
				Bar: 100,
			},
		},
		{
			in: func(st *Symtab, dst *Buffer) {
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("foo"))
				dst.WriteString("foo")
				dst.BeginField(st.Intern("bar"))
				dst.WriteInt(100)
				dst.BeginField(st.Intern("list"))
				dst.BeginList(-1)
				for i := 0; i < 3; i++ {
					dst.WriteInt(int64(i))
				}
				dst.EndList()
				dst.BeginField(st.Intern("map"))
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("first"))
				dst.WriteInt(1)
				dst.BeginField(st.Intern("second"))
				dst.WriteInt(2)
				dst.BeginField(st.Intern("third"))
				dst.WriteBool(false)
				dst.EndStruct()
				dst.EndStruct()
			},
			out: map[string]any{
				"foo":  "foo",
				"bar":  uint64(100),
				"list": []any{uint64(0), uint64(1), uint64(2)},
				"map": map[string]any{
					"first":  uint64(1),
					"second": uint64(2),
					"third":  false,
				},
			},
		},
		{
			// recursive compilation + population of pointers:
			in: func(st *Symtab, dst *Buffer) {
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("self"))
				dst.WriteInt(0)
				dst.BeginField(st.Intern("recur"))
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("self"))
				dst.WriteInt(1)
				dst.BeginField(st.Intern("recur"))
				dst.WriteNull()
				dst.EndStruct()
				dst.EndStruct()
			},
			out: &recur{
				Self: 0,
				Rest: &recur{Self: 1, Rest: nil},
			},
		},
	}
	var st Symtab
	var dst Buffer
	for i := range tcs {
		dst.Reset()
		st.Reset()
		fn := tcs[i].in
		want := tcs[i].out
		t.Run(fmt.Sprintf("case-%d", i), func(t *testing.T) {
			fn(&st, &dst)
			alt := reflect.New(reflect.TypeOf(want)).Interface()
			rest, err := Unmarshal(&st, dst.Bytes(), alt)
			if err != nil {
				t.Fatal(err)
			}
			if len(rest) > 0 {
				t.Errorf("%d bytes remaining", len(rest))
			}
			if !reflect.DeepEqual(reflect.ValueOf(alt).Elem().Interface(), want) {
				t.Errorf("%#v != %#v", alt, want)
			}

			// test Marshal of the desired return value
			// produces and equivalent Unmarshal result
			dst.Reset()
			st.Reset()
			err = Marshal(&st, &dst, alt)
			if err != nil {
				t.Fatal(err)
			}
			alt2 := reflect.New(reflect.TypeOf(want)).Interface()
			_, err = Unmarshal(&st, dst.Bytes(), alt2)
			if err != nil {
				t.Fatal(err)
			}
			if !reflect.DeepEqual(reflect.ValueOf(alt).Elem().Interface(), want) {
				t.Errorf("%#v != %#v", alt2, want)
			}
		})
	}
}

func BenchmarkMarshalUnmarshal(b *testing.B) {
	tcs := []struct {
		in  func(st *Symtab, dst *Buffer)
		out any
	}{
		{
			in: func(st *Symtab, dst *Buffer) {
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("foo"))
				dst.WriteString("foo")
				dst.BeginField(st.Intern("bar"))
				dst.WriteFloat64(100.0) // will convert to int successfully
				dst.BeginField(st.Intern("AlsoIgnored"))
				dst.WriteString("ignore me")
				dst.EndStruct()
			},
			out: struct {
				Foo         string `ion:"foo"`
				Bar         int    `ion:"bar"`
				ignored     int
				AlsoIgnored string `ion:"-"`
			}{
				Foo: "foo",
				Bar: 100,
			},
		},
		{
			// a bit of a worst-case scenario here:
			in: func(st *Symtab, dst *Buffer) {
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("foo"))
				dst.WriteString("foo")
				dst.BeginField(st.Intern("bar"))
				dst.WriteInt(100)
				dst.BeginField(st.Intern("list"))
				dst.BeginList(-1)
				for i := 0; i < 3; i++ {
					dst.WriteInt(int64(i))
				}
				dst.EndList()
				dst.BeginField(st.Intern("map"))
				dst.BeginStruct(-1)
				dst.BeginField(st.Intern("first"))
				dst.WriteInt(1)
				dst.BeginField(st.Intern("second"))
				dst.WriteInt(2)
				dst.BeginField(st.Intern("third"))
				dst.WriteBool(false)
				dst.EndStruct()
				dst.EndStruct()
			},
			out: map[string]any{
				"foo":  "foo",
				"bar":  uint64(100),
				"list": []any{uint64(0), uint64(1), uint64(2)},
				"map": map[string]any{
					"first":  uint64(1),
					"second": uint64(2),
					"third":  false,
				},
			},
		},
	}
	var st Symtab
	var dst Buffer
	for i := range tcs {
		dst.Reset()
		st.Reset()
		fn := tcs[i].in
		want := tcs[i].out
		b.Run(fmt.Sprintf("unmarshal/case-%d", i), func(b *testing.B) {
			fn(&st, &dst)
			alt := reflect.New(reflect.TypeOf(want)).Interface()
			b.ReportAllocs()
			b.SetBytes(int64(dst.Size()))
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_, err := Unmarshal(&st, dst.Bytes(), alt)
				if err != nil {
					b.Fatal(err)
				}
			}
		})
		b.Run(fmt.Sprintf("marshal/case-%d", i), func(b *testing.B) {
			fn(&st, &dst)
			b.ReportAllocs()
			b.SetBytes(int64(dst.Size()))
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				dst.Reset()
				err := Marshal(&st, &dst, want)
				if err != nil {
					b.Fatal(err)
				}
			}
		})
	}
}

func BenchmarkReadIntMagnitude(b *testing.B) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20}},
		{255, []byte{0x21, 0xff}},
		{65535, []byte{0x22, 0xff, 0xff}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{1, []byte{0x21, 0x01}},
		{257, []byte{0x22, 0x01, 0x01}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{127, []byte{0x21, 0x7f}},
		{32639, []byte{0x22, 0x7f, 0x7f}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
	}

	for i := 0; i < b.N; i++ {
		for _, input := range testcases {
			_, _, _ = ReadIntMagnitude(input.encoded)
		}
	}
}

func BenchmarkReadIntMagnitudeFromIonWithExtraPaddingAfterValues(b *testing.B) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{255, []byte{0x21, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65535, []byte{0x22, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{257, []byte{0x22, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{258, []byte{0x22, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{127, []byte{0x21, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{32639, []byte{0x22, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	}

	for i := 0; i < b.N; i++ {
		for _, input := range testcases {
			_, _, _ = ReadIntMagnitude(input.encoded)
		}
	}
}

func BenchmarkReadTime(b *testing.B) {
	mkts := func(s string) []byte {
		d, ok := date.Parse([]byte(s))
		if !ok {
			panic("bad date: " + s)
		}
		var b Buffer
		b.WriteTime(d)
		return b.Bytes()
	}
	times := [][]byte{
		mkts("2022-04-05T07:20:50"),
		mkts("2022-04-05T07:20:50.52334"),
		mkts("2022-04-05T12:24:32.999999999"),
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ReadTime(times[i%len(times)])
	}
}

func BenchmarkWriteTime(b *testing.B) {
	mkts := func(s string) date.Time {
		d, ok := date.Parse([]byte(s))
		if !ok {
			panic("bad date: " + s)
		}
		return d
	}
	times := []date.Time{
		mkts("2022-04-05T07:20:50"),
		mkts("2022-04-05T07:20:50.52334"),
		mkts("2022-04-05T12:24:32.999999999"),
	}
	var buf Buffer
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		buf.WriteTime(times[i%len(times)])
		buf.Reset()
	}
}
