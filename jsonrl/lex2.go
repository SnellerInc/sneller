//line lex2.rl:1
// Copyright (C) 2022 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Code generated by ragel. DO NOT EDIT.

package jsonrl

import (
	"fmt"
	"unicode/utf8"
)

//line lex2.rl:84

//line lex2.go:32
const struct_field_start int = 1
const struct_field_first_final int = 57
const struct_field_error int = 0

const struct_field_en_main int = 1

//line lex2.rl:144

func (t *parser) lexField(b *reader) error {
	if !b.assertFill() {
		if b.err != nil {
			return b.err
		}
		return fmt.Errorf("%w (unexpected EOF looking for struct field)", ErrNoMatch)
	}
	needmore := false
	for b.err == nil {
		t.tok = tokDatum
		t.auxtok = tokDatum
		neg, nege, esc, fieldesc := false, false, false, false
		sbegin, send := 0, 0
		curi, cure, dc := uint64(0), int(0), int(0)
		var field []byte
		data := b.avail()
		cs, p, pe, eof := 0, 0, len(data), len(data)
		_ = eof

//line lex2.go:62
		{
			cs = struct_field_start
		}

//line lex2.go:67
		{
			if p == pe {
				goto _test_eof
			}
			switch cs {
			case 1:
				goto st_case_1
			case 0:
				goto st_case_0
			case 2:
				goto st_case_2
			case 3:
				goto st_case_3
			case 4:
				goto st_case_4
			case 5:
				goto st_case_5
			case 6:
				goto st_case_6
			case 7:
				goto st_case_7
			case 8:
				goto st_case_8
			case 57:
				goto st_case_57
			case 9:
				goto st_case_9
			case 10:
				goto st_case_10
			case 11:
				goto st_case_11
			case 12:
				goto st_case_12
			case 13:
				goto st_case_13
			case 14:
				goto st_case_14
			case 15:
				goto st_case_15
			case 16:
				goto st_case_16
			case 17:
				goto st_case_17
			case 18:
				goto st_case_18
			case 19:
				goto st_case_19
			case 20:
				goto st_case_20
			case 21:
				goto st_case_21
			case 22:
				goto st_case_22
			case 23:
				goto st_case_23
			case 24:
				goto st_case_24
			case 25:
				goto st_case_25
			case 26:
				goto st_case_26
			case 27:
				goto st_case_27
			case 28:
				goto st_case_28
			case 29:
				goto st_case_29
			case 30:
				goto st_case_30
			case 31:
				goto st_case_31
			case 32:
				goto st_case_32
			case 33:
				goto st_case_33
			case 34:
				goto st_case_34
			case 35:
				goto st_case_35
			case 36:
				goto st_case_36
			case 37:
				goto st_case_37
			case 38:
				goto st_case_38
			case 39:
				goto st_case_39
			case 40:
				goto st_case_40
			case 41:
				goto st_case_41
			case 42:
				goto st_case_42
			case 43:
				goto st_case_43
			case 44:
				goto st_case_44
			case 45:
				goto st_case_45
			case 46:
				goto st_case_46
			case 47:
				goto st_case_47
			case 48:
				goto st_case_48
			case 49:
				goto st_case_49
			case 50:
				goto st_case_50
			case 51:
				goto st_case_51
			case 52:
				goto st_case_52
			case 53:
				goto st_case_53
			case 54:
				goto st_case_54
			case 55:
				goto st_case_55
			case 56:
				goto st_case_56
			}
			goto st_out
		st1:
			if p++; p == pe {
				goto _test_eof1
			}
		st_case_1:
			switch data[p] {
			case 32:
				goto st1
			case 34:
				goto st2
			case 125:
				goto tr3
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st1
			}
			goto st0
		st_case_0:
		st0:
			cs = 0
			goto _out
		st2:
			if p++; p == pe {
				goto _test_eof2
			}
		st_case_2:
//line lex2.rl:59
			esc = false
			sbegin = p
//line lex2.rl:59
			send = p
//line lex2.go:221
			switch data[p] {
			case 34:
				goto tr5
			case 92:
				goto tr6
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st48
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st53
				}
			default:
				goto st50
			}
			goto st3
		tr92:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		tr100:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		tr109:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		st3:
			if p++; p == pe {
				goto _test_eof3
			}
		st_case_3:
//line lex2.rl:59
			send = p
//line lex2.go:285
			switch data[p] {
			case 34:
				goto tr5
			case 92:
				goto tr6
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st48
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st53
				}
			default:
				goto st50
			}
			goto st3
		tr5:
//line lex2.rl:90

			field = data[sbegin:send]
			fieldesc = esc

			goto st4
		tr93:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:90

			field = data[sbegin:send]
			fieldesc = esc

			goto st4
		tr101:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:90

			field = data[sbegin:send]
			fieldesc = esc

			goto st4
		tr110:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:90

			field = data[sbegin:send]
			fieldesc = esc

			goto st4
		st4:
			if p++; p == pe {
				goto _test_eof4
			}
		st_case_4:
//line lex2.go:369
			switch data[p] {
			case 32:
				goto st4
			case 58:
				goto st5
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st4
			}
			goto st0
		st5:
			if p++; p == pe {
				goto _test_eof5
			}
		st_case_5:
			switch data[p] {
			case 32:
				goto st5
			case 34:
				goto st6
			case 45:
				goto tr13
			case 91:
				goto tr15
			case 102:
				goto st30
			case 110:
				goto st35
			case 116:
				goto st39
			case 123:
				goto tr19
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr14
				}
			case data[p] >= 9:
				goto st5
			}
			goto st0
		st6:
			if p++; p == pe {
				goto _test_eof6
			}
		st_case_6:
//line lex2.rl:59
			esc = false
			sbegin = p
//line lex2.rl:59
			send = p
//line lex2.go:421
			switch data[p] {
			case 34:
				goto st8
			case 92:
				goto tr22
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st14
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st19
				}
			default:
				goto st16
			}
			goto st7
		tr33:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st7
		tr41:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st7
		tr50:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st7
		st7:
			if p++; p == pe {
				goto _test_eof7
			}
		st_case_7:
//line lex2.rl:59
			send = p
//line lex2.go:485
			switch data[p] {
			case 34:
				goto st8
			case 92:
				goto tr22
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st14
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st19
				}
			default:
				goto st16
			}
			goto st7
		tr34:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st8
		tr42:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st8
		tr51:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st8
		st8:
			if p++; p == pe {
				goto _test_eof8
			}
		st_case_8:
//line lex2.go:547
			switch data[p] {
			case 32:
				goto st8
			case 44:
				goto tr26
			case 125:
				goto tr27
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st8
			}
			goto st0
		tr3:
//line lex2.rl:138
			t.tok = tokRBrace
			goto ret
			goto st57
		tr15:
//line lex2.rl:83
			t.tok = tokLBrack
//line lex2.rl:132

			t.output.beginField(field, fieldesc)
			goto ret

			goto st57
		tr19:
//line lex2.rl:82
			t.tok = tokLBrace
//line lex2.rl:132

			t.output.beginField(field, fieldesc)
			goto ret

			goto st57
		tr26:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:127

			t.output.beginField(field, fieldesc)
			t.output.parseString(data[sbegin:send], esc)
			goto ret

			goto st57
		tr27:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:127

			t.output.beginField(field, fieldesc)
			t.output.parseString(data[sbegin:send], esc)
			goto ret

			goto st57
		tr57:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:120
			{
				i := int64(curi)
				if neg {
					i = -i
				}
				t.output.beginField(field, fieldesc)
				t.output.parseInt(i)
				goto ret
			}
			goto st57
		tr59:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:120
			{
				i := int64(curi)
				if neg {
					i = -i
				}
				t.output.beginField(field, fieldesc)
				t.output.parseInt(i)
				goto ret
			}
			goto st57
		tr61:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:115

			t.output.beginField(field, fieldesc)
			atof(t.output, curi, dc, neg)
			goto ret

			goto st57
		tr64:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:115

			t.output.beginField(field, fieldesc)
			atof(t.output, curi, dc, neg)
			goto ret

			goto st57
		tr67:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:115

			t.output.beginField(field, fieldesc)
			atof(t.output, curi, dc, neg)
			goto ret

			goto st57
		tr70:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:115

			t.output.beginField(field, fieldesc)
			atof(t.output, curi, dc, neg)
			goto ret

			goto st57
		tr75:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:110

			t.output.beginField(field, fieldesc)
			t.output.parseBool(false)
			goto ret

			goto st57
		tr76:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:110

			t.output.beginField(field, fieldesc)
			t.output.parseBool(false)
			goto ret

			goto st57
		tr80:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:100

			t.output.beginField(field, fieldesc)
			t.output.parseNull()
			goto ret

			goto st57
		tr81:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:100

			t.output.beginField(field, fieldesc)
			t.output.parseNull()
			goto ret

			goto st57
		tr85:
//line lex2.rl:96
			t.auxtok = tokComma
//line lex2.rl:105

			t.output.beginField(field, fieldesc)
			t.output.parseBool(true)
			goto ret

			goto st57
		tr86:
//line lex2.rl:97
			t.auxtok = tokRBrace
//line lex2.rl:105

			t.output.beginField(field, fieldesc)
			t.output.parseBool(true)
			goto ret

			goto st57
		st57:
			if p++; p == pe {
				goto _test_eof57
			}
		st_case_57:
//line lex2.go:745
			goto st0
		tr22:
//line lex2.rl:28
			esc = true
			goto st9
		tr35:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st9
		tr43:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st9
		tr52:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st9
		st9:
			if p++; p == pe {
				goto _test_eof9
			}
		st_case_9:
//line lex2.go:789
			switch data[p] {
			case 34:
				goto st7
			case 47:
				goto st7
			case 92:
				goto st7
			case 102:
				goto st7
			case 110:
				goto st7
			case 114:
				goto st7
			case 117:
				goto st10
			}
			switch {
			case data[p] > 98:
				if 116 <= data[p] && data[p] <= 118 {
					goto st7
				}
			case data[p] >= 97:
				goto st7
			}
			goto st0
		st10:
			if p++; p == pe {
				goto _test_eof10
			}
		st_case_10:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st11
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st11
				}
			default:
				goto st11
			}
			goto st0
		st11:
			if p++; p == pe {
				goto _test_eof11
			}
		st_case_11:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st12
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st12
				}
			default:
				goto st12
			}
			goto st0
		st12:
			if p++; p == pe {
				goto _test_eof12
			}
		st_case_12:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st13
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st13
				}
			default:
				goto st13
			}
			goto st0
		st13:
			if p++; p == pe {
				goto _test_eof13
			}
		st_case_13:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st7
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st7
				}
			default:
				goto st7
			}
			goto st0
		tr36:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st14
		tr44:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st14
		tr53:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st14
		st14:
			if p++; p == pe {
				goto _test_eof14
			}
		st_case_14:
//line lex2.go:919
			if 128 <= data[p] && data[p] <= 191 {
				goto st15
			}
			goto st0
		st15:
			if p++; p == pe {
				goto _test_eof15
			}
		st_case_15:
//line lex2.rl:59
			send = p
//line lex2.go:931
			switch data[p] {
			case 34:
				goto tr34
			case 92:
				goto tr35
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr36
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr38
				}
			default:
				goto tr37
			}
			goto tr33
		tr37:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st16
		tr45:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st16
		tr54:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st16
		st16:
			if p++; p == pe {
				goto _test_eof16
			}
		st_case_16:
//line lex2.go:993
			if 128 <= data[p] && data[p] <= 191 {
				goto st17
			}
			goto st0
		st17:
			if p++; p == pe {
				goto _test_eof17
			}
		st_case_17:
			if 128 <= data[p] && data[p] <= 191 {
				goto st18
			}
			goto st0
		st18:
			if p++; p == pe {
				goto _test_eof18
			}
		st_case_18:
//line lex2.rl:59
			send = p
//line lex2.go:1014
			switch data[p] {
			case 34:
				goto tr42
			case 92:
				goto tr43
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr44
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr46
				}
			default:
				goto tr45
			}
			goto tr41
		tr38:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st19
		tr46:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st19
		tr55:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st19
		st19:
			if p++; p == pe {
				goto _test_eof19
			}
		st_case_19:
//line lex2.go:1076
			if 128 <= data[p] && data[p] <= 191 {
				goto st20
			}
			goto st0
		st20:
			if p++; p == pe {
				goto _test_eof20
			}
		st_case_20:
			if 128 <= data[p] && data[p] <= 191 {
				goto st21
			}
			goto st0
		st21:
			if p++; p == pe {
				goto _test_eof21
			}
		st_case_21:
			if 128 <= data[p] && data[p] <= 191 {
				goto st22
			}
			goto st0
		st22:
			if p++; p == pe {
				goto _test_eof22
			}
		st_case_22:
//line lex2.rl:59
			send = p
//line lex2.go:1106
			switch data[p] {
			case 34:
				goto tr51
			case 92:
				goto tr52
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr53
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr55
				}
			default:
				goto tr54
			}
			goto tr50
		tr13:
//line lex2.rl:62
			neg = true
//line lex2.rl:77
			neg = true
			goto st23
		st23:
			if p++; p == pe {
				goto _test_eof23
			}
		st_case_23:
//line lex2.go:1147
			if 48 <= data[p] && data[p] <= 57 {
				goto tr14
			}
			goto st0
		tr14:
//line lex2.rl:61
			curi *= 10
			curi += uint64(data[p] - '0')
			goto st24
		st24:
			if p++; p == pe {
				goto _test_eof24
			}
		st_case_24:
//line lex2.go:1161
			switch data[p] {
			case 32:
				goto st25
			case 44:
				goto tr57
			case 46:
				goto st26
			case 125:
				goto tr59
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr14
				}
			case data[p] >= 9:
				goto st25
			}
			goto st0
		st25:
			if p++; p == pe {
				goto _test_eof25
			}
		st_case_25:
			switch data[p] {
			case 32:
				goto st25
			case 44:
				goto tr57
			case 125:
				goto tr59
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st25
			}
			goto st0
		tr62:
//line lex2.rl:65
			curi *= 10
			curi += uint64(data[p] - '0')
			dc--
			goto st26
		st26:
			if p++; p == pe {
				goto _test_eof26
			}
		st_case_26:
//line lex2.go:1207
			switch data[p] {
			case 32:
				goto st27
			case 44:
				goto tr61
			case 69:
				goto st28
			case 101:
				goto st28
			case 125:
				goto tr64
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr62
				}
			case data[p] >= 9:
				goto st27
			}
			goto st0
		tr65:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

			goto st27
		st27:
			if p++; p == pe {
				goto _test_eof27
			}
		st_case_27:
//line lex2.go:1243
			switch data[p] {
			case 32:
				goto st27
			case 44:
				goto tr61
			case 125:
				goto tr64
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st27
			}
			goto st0
		st28:
			if p++; p == pe {
				goto _test_eof28
			}
		st_case_28:
			switch data[p] {
			case 32:
				goto tr65
			case 43:
				goto st29
			case 44:
				goto tr67
			case 45:
				goto tr68
			case 125:
				goto tr70
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr69
				}
			case data[p] >= 9:
				goto tr65
			}
			goto st0
		tr68:
//line lex2.rl:67
			nege = true
			goto st29
		tr69:
//line lex2.rl:67
			cure *= 10
			cure += int(data[p]) - '0'
			goto st29
		st29:
			if p++; p == pe {
				goto _test_eof29
			}
		st_case_29:
//line lex2.go:1295
			switch data[p] {
			case 32:
				goto tr65
			case 44:
				goto tr67
			case 125:
				goto tr70
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr69
				}
			case data[p] >= 9:
				goto tr65
			}
			goto st0
		st30:
			if p++; p == pe {
				goto _test_eof30
			}
		st_case_30:
			if data[p] == 97 {
				goto st31
			}
			goto st0
		st31:
			if p++; p == pe {
				goto _test_eof31
			}
		st_case_31:
			if data[p] == 108 {
				goto st32
			}
			goto st0
		st32:
			if p++; p == pe {
				goto _test_eof32
			}
		st_case_32:
			if data[p] == 115 {
				goto st33
			}
			goto st0
		st33:
			if p++; p == pe {
				goto _test_eof33
			}
		st_case_33:
			if data[p] == 101 {
				goto st34
			}
			goto st0
		st34:
			if p++; p == pe {
				goto _test_eof34
			}
		st_case_34:
			switch data[p] {
			case 32:
				goto st34
			case 44:
				goto tr75
			case 125:
				goto tr76
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st34
			}
			goto st0
		st35:
			if p++; p == pe {
				goto _test_eof35
			}
		st_case_35:
			if data[p] == 117 {
				goto st36
			}
			goto st0
		st36:
			if p++; p == pe {
				goto _test_eof36
			}
		st_case_36:
			if data[p] == 108 {
				goto st37
			}
			goto st0
		st37:
			if p++; p == pe {
				goto _test_eof37
			}
		st_case_37:
			if data[p] == 108 {
				goto st38
			}
			goto st0
		st38:
			if p++; p == pe {
				goto _test_eof38
			}
		st_case_38:
			switch data[p] {
			case 32:
				goto st38
			case 44:
				goto tr80
			case 125:
				goto tr81
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st38
			}
			goto st0
		st39:
			if p++; p == pe {
				goto _test_eof39
			}
		st_case_39:
			if data[p] == 114 {
				goto st40
			}
			goto st0
		st40:
			if p++; p == pe {
				goto _test_eof40
			}
		st_case_40:
			if data[p] == 117 {
				goto st41
			}
			goto st0
		st41:
			if p++; p == pe {
				goto _test_eof41
			}
		st_case_41:
			if data[p] == 101 {
				goto st42
			}
			goto st0
		st42:
			if p++; p == pe {
				goto _test_eof42
			}
		st_case_42:
			switch data[p] {
			case 32:
				goto st42
			case 44:
				goto tr85
			case 125:
				goto tr86
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st42
			}
			goto st0
		tr6:
//line lex2.rl:28
			esc = true
			goto st43
		tr94:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st43
		tr102:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st43
		tr111:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st43
		st43:
			if p++; p == pe {
				goto _test_eof43
			}
		st_case_43:
//line lex2.go:1496
			switch data[p] {
			case 34:
				goto st3
			case 47:
				goto st3
			case 92:
				goto st3
			case 102:
				goto st3
			case 110:
				goto st3
			case 114:
				goto st3
			case 117:
				goto st44
			}
			switch {
			case data[p] > 98:
				if 116 <= data[p] && data[p] <= 118 {
					goto st3
				}
			case data[p] >= 97:
				goto st3
			}
			goto st0
		st44:
			if p++; p == pe {
				goto _test_eof44
			}
		st_case_44:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st45
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st45
				}
			default:
				goto st45
			}
			goto st0
		st45:
			if p++; p == pe {
				goto _test_eof45
			}
		st_case_45:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st46
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st46
				}
			default:
				goto st46
			}
			goto st0
		st46:
			if p++; p == pe {
				goto _test_eof46
			}
		st_case_46:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st47
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st47
				}
			default:
				goto st47
			}
			goto st0
		st47:
			if p++; p == pe {
				goto _test_eof47
			}
		st_case_47:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st3
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st3
				}
			default:
				goto st3
			}
			goto st0
		tr95:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st48
		tr103:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st48
		tr112:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st48
		st48:
			if p++; p == pe {
				goto _test_eof48
			}
		st_case_48:
//line lex2.go:1626
			if 128 <= data[p] && data[p] <= 191 {
				goto st49
			}
			goto st0
		st49:
			if p++; p == pe {
				goto _test_eof49
			}
		st_case_49:
//line lex2.rl:59
			send = p
//line lex2.go:1638
			switch data[p] {
			case 34:
				goto tr93
			case 92:
				goto tr94
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr95
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr97
				}
			default:
				goto tr96
			}
			goto tr92
		tr96:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st50
		tr104:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st50
		tr113:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st50
		st50:
			if p++; p == pe {
				goto _test_eof50
			}
		st_case_50:
//line lex2.go:1700
			if 128 <= data[p] && data[p] <= 191 {
				goto st51
			}
			goto st0
		st51:
			if p++; p == pe {
				goto _test_eof51
			}
		st_case_51:
			if 128 <= data[p] && data[p] <= 191 {
				goto st52
			}
			goto st0
		st52:
			if p++; p == pe {
				goto _test_eof52
			}
		st_case_52:
//line lex2.rl:59
			send = p
//line lex2.go:1721
			switch data[p] {
			case 34:
				goto tr101
			case 92:
				goto tr102
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr103
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr105
				}
			default:
				goto tr104
			}
			goto tr100
		tr97:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st53
		tr105:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st53
		tr114:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st53
		st53:
			if p++; p == pe {
				goto _test_eof53
			}
		st_case_53:
//line lex2.go:1783
			if 128 <= data[p] && data[p] <= 191 {
				goto st54
			}
			goto st0
		st54:
			if p++; p == pe {
				goto _test_eof54
			}
		st_case_54:
			if 128 <= data[p] && data[p] <= 191 {
				goto st55
			}
			goto st0
		st55:
			if p++; p == pe {
				goto _test_eof55
			}
		st_case_55:
			if 128 <= data[p] && data[p] <= 191 {
				goto st56
			}
			goto st0
		st56:
			if p++; p == pe {
				goto _test_eof56
			}
		st_case_56:
//line lex2.rl:59
			send = p
//line lex2.go:1813
			switch data[p] {
			case 34:
				goto tr110
			case 92:
				goto tr111
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr112
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr114
				}
			default:
				goto tr113
			}
			goto tr109
		st_out:
		_test_eof1:
			cs = 1
			goto _test_eof
		_test_eof2:
			cs = 2
			goto _test_eof
		_test_eof3:
			cs = 3
			goto _test_eof
		_test_eof4:
			cs = 4
			goto _test_eof
		_test_eof5:
			cs = 5
			goto _test_eof
		_test_eof6:
			cs = 6
			goto _test_eof
		_test_eof7:
			cs = 7
			goto _test_eof
		_test_eof8:
			cs = 8
			goto _test_eof
		_test_eof57:
			cs = 57
			goto _test_eof
		_test_eof9:
			cs = 9
			goto _test_eof
		_test_eof10:
			cs = 10
			goto _test_eof
		_test_eof11:
			cs = 11
			goto _test_eof
		_test_eof12:
			cs = 12
			goto _test_eof
		_test_eof13:
			cs = 13
			goto _test_eof
		_test_eof14:
			cs = 14
			goto _test_eof
		_test_eof15:
			cs = 15
			goto _test_eof
		_test_eof16:
			cs = 16
			goto _test_eof
		_test_eof17:
			cs = 17
			goto _test_eof
		_test_eof18:
			cs = 18
			goto _test_eof
		_test_eof19:
			cs = 19
			goto _test_eof
		_test_eof20:
			cs = 20
			goto _test_eof
		_test_eof21:
			cs = 21
			goto _test_eof
		_test_eof22:
			cs = 22
			goto _test_eof
		_test_eof23:
			cs = 23
			goto _test_eof
		_test_eof24:
			cs = 24
			goto _test_eof
		_test_eof25:
			cs = 25
			goto _test_eof
		_test_eof26:
			cs = 26
			goto _test_eof
		_test_eof27:
			cs = 27
			goto _test_eof
		_test_eof28:
			cs = 28
			goto _test_eof
		_test_eof29:
			cs = 29
			goto _test_eof
		_test_eof30:
			cs = 30
			goto _test_eof
		_test_eof31:
			cs = 31
			goto _test_eof
		_test_eof32:
			cs = 32
			goto _test_eof
		_test_eof33:
			cs = 33
			goto _test_eof
		_test_eof34:
			cs = 34
			goto _test_eof
		_test_eof35:
			cs = 35
			goto _test_eof
		_test_eof36:
			cs = 36
			goto _test_eof
		_test_eof37:
			cs = 37
			goto _test_eof
		_test_eof38:
			cs = 38
			goto _test_eof
		_test_eof39:
			cs = 39
			goto _test_eof
		_test_eof40:
			cs = 40
			goto _test_eof
		_test_eof41:
			cs = 41
			goto _test_eof
		_test_eof42:
			cs = 42
			goto _test_eof
		_test_eof43:
			cs = 43
			goto _test_eof
		_test_eof44:
			cs = 44
			goto _test_eof
		_test_eof45:
			cs = 45
			goto _test_eof
		_test_eof46:
			cs = 46
			goto _test_eof
		_test_eof47:
			cs = 47
			goto _test_eof
		_test_eof48:
			cs = 48
			goto _test_eof
		_test_eof49:
			cs = 49
			goto _test_eof
		_test_eof50:
			cs = 50
			goto _test_eof
		_test_eof51:
			cs = 51
			goto _test_eof
		_test_eof52:
			cs = 52
			goto _test_eof
		_test_eof53:
			cs = 53
			goto _test_eof
		_test_eof54:
			cs = 54
			goto _test_eof
		_test_eof55:
			cs = 55
			goto _test_eof
		_test_eof56:
			cs = 56
			goto _test_eof

		_test_eof:
			{
			}
		_out:
			{
			}
		}

//line lex2.rl:167

		goto no
	ret: // jumped to from body:
		if t.tok == tokRBrace && needmore {
			return fmt.Errorf("%w: rejecting ',' before '}'", ErrNoMatch)
		}
		b.rpos += p + 1
		// if we see ',' then keep looping
		if t.tok == tokDatum && t.auxtok == tokComma {
			err := t.output.out.CheckSize()
			if err != nil {
				return err
			}
			needmore = true
			continue
		}
		return nil
	no: // fallthrough path
		if p < len(data) {
			return fmt.Errorf("lexing struct field: %w", ErrNoMatch)
		}
		if len(data) >= MaxDatumSize {
			if field != nil {
				return fmt.Errorf("field %q: %w", field, ErrTooLarge)
			}
			return fmt.Errorf("struct field: %w", ErrTooLarge)
		}
		if b.atEOF {
			return fmt.Errorf("%w (unexpected EOF)", ErrNoMatch)
		}
		b.fill()
	}
	return b.err
}

//line lex2.go:1943
const struct_cont_start int = 1
const struct_cont_first_final int = 2
const struct_cont_error int = 0

const struct_cont_en_main int = 1

//line lex2.rl:208

func (t *parser) lexMoreStruct(b *reader) error {
	if !b.assertFill() {
		if b.err != nil {
			return b.err
		}
		return fmt.Errorf("%w (unexpected EOF looking for struct field)", ErrNoMatch)
	}
	for b.err == nil {
		data := b.avail()
		cs, p, pe, eof := 0, 0, len(data), len(data)
		_ = eof

//line lex2.go:1966
		{
			cs = struct_cont_start
		}

//line lex2.go:1971
		{
			if p == pe {
				goto _test_eof
			}
			switch cs {
			case 1:
				goto st_case_1
			case 0:
				goto st_case_0
			case 2:
				goto st_case_2
			}
			goto st_out
		st1:
			if p++; p == pe {
				goto _test_eof1
			}
		st_case_1:
			switch data[p] {
			case 32:
				goto st1
			case 44:
				goto tr2
			case 125:
				goto tr3
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st1
			}
			goto st0
		st_case_0:
		st0:
			cs = 0
			goto _out
		tr2:
//line lex2.rl:204
			t.tok = tokComma
//line lex2.rl:206
			b.rpos += p + 1
			return nil
			goto st2
		tr3:
//line lex2.rl:205
			t.tok = tokRBrace
//line lex2.rl:206
			b.rpos += p + 1
			return nil
			goto st2
		st2:
			if p++; p == pe {
				goto _test_eof2
			}
		st_case_2:
//line lex2.go:2023
			goto st0
		st_out:
		_test_eof1:
			cs = 1
			goto _test_eof
		_test_eof2:
			cs = 2
			goto _test_eof

		_test_eof:
			{
			}
		_out:
			{
			}
		}

//line lex2.rl:224

		if p < len(data) {
			return fmt.Errorf("%w (couldn't find ',' or '}' in struct)", ErrNoMatch)
		}
		if len(data) >= MaxDatumSize {
			return fmt.Errorf("struct whitespace: %w", ErrTooLarge)
		}
		if b.atEOF {
			return fmt.Errorf("%w (unexpected EOF looking ',' or '}')", ErrNoMatch)
		}
		b.fill()
	}
	return b.err
}

//line lex2.go:2050
const list_field_start int = 1
const list_field_first_final int = 39
const list_field_error int = 0

const list_field_en_main int = 1

//line lex2.rl:279

func (t *parser) lexListField(b *reader) error {
	if !b.assertFill() {
		if b.err != nil {
			return b.err
		}
		return fmt.Errorf("%w (unexpected EOF looking for struct field)", ErrNoMatch)
	}
	needmore := false
	for b.err == nil {
		t.tok = tokDatum
		t.auxtok = tokDatum
		neg, nege, esc := false, false, false
		sbegin, send := 0, 0
		curi, cure, dc := uint64(0), int(0), int(0)
		data := b.avail()
		cs, p, pe, eof := 0, 0, len(data), len(data)
		_ = eof

//line lex2.go:2079
		{
			cs = list_field_start
		}

//line lex2.go:2084
		{
			if p == pe {
				goto _test_eof
			}
			switch cs {
			case 1:
				goto st_case_1
			case 0:
				goto st_case_0
			case 2:
				goto st_case_2
			case 3:
				goto st_case_3
			case 4:
				goto st_case_4
			case 39:
				goto st_case_39
			case 5:
				goto st_case_5
			case 6:
				goto st_case_6
			case 7:
				goto st_case_7
			case 8:
				goto st_case_8
			case 9:
				goto st_case_9
			case 10:
				goto st_case_10
			case 11:
				goto st_case_11
			case 12:
				goto st_case_12
			case 13:
				goto st_case_13
			case 14:
				goto st_case_14
			case 15:
				goto st_case_15
			case 16:
				goto st_case_16
			case 17:
				goto st_case_17
			case 18:
				goto st_case_18
			case 19:
				goto st_case_19
			case 20:
				goto st_case_20
			case 21:
				goto st_case_21
			case 22:
				goto st_case_22
			case 23:
				goto st_case_23
			case 24:
				goto st_case_24
			case 25:
				goto st_case_25
			case 26:
				goto st_case_26
			case 27:
				goto st_case_27
			case 28:
				goto st_case_28
			case 29:
				goto st_case_29
			case 30:
				goto st_case_30
			case 31:
				goto st_case_31
			case 32:
				goto st_case_32
			case 33:
				goto st_case_33
			case 34:
				goto st_case_34
			case 35:
				goto st_case_35
			case 36:
				goto st_case_36
			case 37:
				goto st_case_37
			case 38:
				goto st_case_38
			}
			goto st_out
		st1:
			if p++; p == pe {
				goto _test_eof1
			}
		st_case_1:
			switch data[p] {
			case 32:
				goto st1
			case 34:
				goto st2
			case 45:
				goto tr3
			case 91:
				goto tr5
			case 93:
				goto tr6
			case 102:
				goto st26
			case 110:
				goto st31
			case 116:
				goto st35
			case 123:
				goto tr10
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr4
				}
			case data[p] >= 9:
				goto st1
			}
			goto st0
		st_case_0:
		st0:
			cs = 0
			goto _out
		st2:
			if p++; p == pe {
				goto _test_eof2
			}
		st_case_2:
//line lex2.rl:59
			esc = false
			sbegin = p
//line lex2.rl:59
			send = p
//line lex2.go:2219
			switch data[p] {
			case 34:
				goto st4
			case 92:
				goto tr13
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st10
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st15
				}
			default:
				goto st12
			}
			goto st3
		tr24:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		tr32:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		tr41:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st3
		st3:
			if p++; p == pe {
				goto _test_eof3
			}
		st_case_3:
//line lex2.rl:59
			send = p
//line lex2.go:2283
			switch data[p] {
			case 34:
				goto st4
			case 92:
				goto tr13
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto st10
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto st15
				}
			default:
				goto st12
			}
			goto st3
		tr25:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st4
		tr33:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st4
		tr42:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st4
		st4:
			if p++; p == pe {
				goto _test_eof4
			}
		st_case_4:
//line lex2.go:2345
			switch data[p] {
			case 32:
				goto st4
			case 44:
				goto tr17
			case 93:
				goto tr18
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st4
			}
			goto st0
		tr5:
//line lex2.rl:83
			t.tok = tokLBrack
//line lex2.rl:274
			goto ret
			goto st39
		tr6:
//line lex2.rl:276
			t.tok = tokRBrack
			b.rpos += p + 1
			return nil
			goto st39
		tr10:
//line lex2.rl:82
			t.tok = tokLBrace
//line lex2.rl:274
			goto ret
			goto st39
		tr17:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:270

			t.output.parseString(data[sbegin:send], esc)
			goto ret

			goto st39
		tr18:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:270

			t.output.parseString(data[sbegin:send], esc)
			goto ret

			goto st39
		tr48:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:264
			{
				i := int64(curi)
				if neg {
					i = -i
				}
				t.output.parseInt(i)
				goto ret
			}
			goto st39
		tr50:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:264
			{
				i := int64(curi)
				if neg {
					i = -i
				}
				t.output.parseInt(i)
				goto ret
			}
			goto st39
		tr52:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:260

			atof(t.output, curi, dc, neg)
			goto ret

			goto st39
		tr55:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:260

			atof(t.output, curi, dc, neg)
			goto ret

			goto st39
		tr58:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:260

			atof(t.output, curi, dc, neg)
			goto ret

			goto st39
		tr61:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:260

			atof(t.output, curi, dc, neg)
			goto ret

			goto st39
		tr66:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:256

			t.output.parseBool(false)
			goto ret

			goto st39
		tr67:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:256

			t.output.parseBool(false)
			goto ret

			goto st39
		tr71:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:248

			t.output.parseNull()
			goto ret

			goto st39
		tr72:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:248

			t.output.parseNull()
			goto ret

			goto st39
		tr76:
//line lex2.rl:244
			t.auxtok = tokComma
//line lex2.rl:252

			t.output.parseBool(true)
			goto ret

			goto st39
		tr77:
//line lex2.rl:245
			t.auxtok = tokRBrack
//line lex2.rl:252

			t.output.parseBool(true)
			goto ret

			goto st39
		st39:
			if p++; p == pe {
				goto _test_eof39
			}
		st_case_39:
//line lex2.go:2523
			goto st0
		tr13:
//line lex2.rl:28
			esc = true
			goto st5
		tr26:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st5
		tr34:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st5
		tr43:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
//line lex2.rl:28
			esc = true
			goto st5
		st5:
			if p++; p == pe {
				goto _test_eof5
			}
		st_case_5:
//line lex2.go:2567
			switch data[p] {
			case 34:
				goto st3
			case 47:
				goto st3
			case 92:
				goto st3
			case 102:
				goto st3
			case 110:
				goto st3
			case 114:
				goto st3
			case 117:
				goto st6
			}
			switch {
			case data[p] > 98:
				if 116 <= data[p] && data[p] <= 118 {
					goto st3
				}
			case data[p] >= 97:
				goto st3
			}
			goto st0
		st6:
			if p++; p == pe {
				goto _test_eof6
			}
		st_case_6:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st7
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st7
				}
			default:
				goto st7
			}
			goto st0
		st7:
			if p++; p == pe {
				goto _test_eof7
			}
		st_case_7:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st8
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st8
				}
			default:
				goto st8
			}
			goto st0
		st8:
			if p++; p == pe {
				goto _test_eof8
			}
		st_case_8:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st9
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st9
				}
			default:
				goto st9
			}
			goto st0
		st9:
			if p++; p == pe {
				goto _test_eof9
			}
		st_case_9:
			switch {
			case data[p] < 65:
				if 48 <= data[p] && data[p] <= 57 {
					goto st3
				}
			case data[p] > 70:
				if 97 <= data[p] && data[p] <= 102 {
					goto st3
				}
			default:
				goto st3
			}
			goto st0
		tr27:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st10
		tr35:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st10
		tr44:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st10
		st10:
			if p++; p == pe {
				goto _test_eof10
			}
		st_case_10:
//line lex2.go:2697
			if 128 <= data[p] && data[p] <= 191 {
				goto st11
			}
			goto st0
		st11:
			if p++; p == pe {
				goto _test_eof11
			}
		st_case_11:
//line lex2.rl:59
			send = p
//line lex2.go:2709
			switch data[p] {
			case 34:
				goto tr25
			case 92:
				goto tr26
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr27
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr29
				}
			default:
				goto tr28
			}
			goto tr24
		tr28:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st12
		tr36:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st12
		tr45:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st12
		st12:
			if p++; p == pe {
				goto _test_eof12
			}
		st_case_12:
//line lex2.go:2771
			if 128 <= data[p] && data[p] <= 191 {
				goto st13
			}
			goto st0
		st13:
			if p++; p == pe {
				goto _test_eof13
			}
		st_case_13:
			if 128 <= data[p] && data[p] <= 191 {
				goto st14
			}
			goto st0
		st14:
			if p++; p == pe {
				goto _test_eof14
			}
		st_case_14:
//line lex2.rl:59
			send = p
//line lex2.go:2792
			switch data[p] {
			case 34:
				goto tr33
			case 92:
				goto tr34
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr35
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr37
				}
			default:
				goto tr36
			}
			goto tr32
		tr29:
//line lex2.rl:33
			{
				r, size := utf8.DecodeRune(data[p-2:])
				if size != 2 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st15
		tr37:
//line lex2.rl:39
			{
				r, size := utf8.DecodeRune(data[p-3:])
				if size != 3 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st15
		tr46:
//line lex2.rl:45
			{
				r, size := utf8.DecodeRune(data[p-4:])
				if size != 4 {
					fmt.Errorf("bad rune %x", r)
				}
			}
			goto st15
		st15:
			if p++; p == pe {
				goto _test_eof15
			}
		st_case_15:
//line lex2.go:2854
			if 128 <= data[p] && data[p] <= 191 {
				goto st16
			}
			goto st0
		st16:
			if p++; p == pe {
				goto _test_eof16
			}
		st_case_16:
			if 128 <= data[p] && data[p] <= 191 {
				goto st17
			}
			goto st0
		st17:
			if p++; p == pe {
				goto _test_eof17
			}
		st_case_17:
			if 128 <= data[p] && data[p] <= 191 {
				goto st18
			}
			goto st0
		st18:
			if p++; p == pe {
				goto _test_eof18
			}
		st_case_18:
//line lex2.rl:59
			send = p
//line lex2.go:2884
			switch data[p] {
			case 34:
				goto tr42
			case 92:
				goto tr43
			}
			switch {
			case data[p] < 224:
				switch {
				case data[p] > 191:
					if 192 <= data[p] && data[p] <= 223 {
						goto tr44
					}
				case data[p] >= 128:
					goto st0
				}
			case data[p] > 239:
				switch {
				case data[p] > 247:
					if 248 <= data[p] {
						goto st0
					}
				case data[p] >= 240:
					goto tr46
				}
			default:
				goto tr45
			}
			goto tr41
		tr3:
//line lex2.rl:62
			neg = true
//line lex2.rl:77
			neg = true
			goto st19
		st19:
			if p++; p == pe {
				goto _test_eof19
			}
		st_case_19:
//line lex2.go:2925
			if 48 <= data[p] && data[p] <= 57 {
				goto tr4
			}
			goto st0
		tr4:
//line lex2.rl:61
			curi *= 10
			curi += uint64(data[p] - '0')
			goto st20
		st20:
			if p++; p == pe {
				goto _test_eof20
			}
		st_case_20:
//line lex2.go:2939
			switch data[p] {
			case 32:
				goto st21
			case 44:
				goto tr48
			case 46:
				goto st22
			case 93:
				goto tr50
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr4
				}
			case data[p] >= 9:
				goto st21
			}
			goto st0
		st21:
			if p++; p == pe {
				goto _test_eof21
			}
		st_case_21:
			switch data[p] {
			case 32:
				goto st21
			case 44:
				goto tr48
			case 93:
				goto tr50
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st21
			}
			goto st0
		tr53:
//line lex2.rl:65
			curi *= 10
			curi += uint64(data[p] - '0')
			dc--
			goto st22
		st22:
			if p++; p == pe {
				goto _test_eof22
			}
		st_case_22:
//line lex2.go:2985
			switch data[p] {
			case 32:
				goto st23
			case 44:
				goto tr52
			case 69:
				goto st24
			case 93:
				goto tr55
			case 101:
				goto st24
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr53
				}
			case data[p] >= 9:
				goto st23
			}
			goto st0
		tr56:
//line lex2.rl:67

			if nege {
				cure = -cure
			}
			dc += cure

			goto st23
		st23:
			if p++; p == pe {
				goto _test_eof23
			}
		st_case_23:
//line lex2.go:3021
			switch data[p] {
			case 32:
				goto st23
			case 44:
				goto tr52
			case 93:
				goto tr55
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st23
			}
			goto st0
		st24:
			if p++; p == pe {
				goto _test_eof24
			}
		st_case_24:
			switch data[p] {
			case 32:
				goto tr56
			case 43:
				goto st25
			case 44:
				goto tr58
			case 45:
				goto tr59
			case 93:
				goto tr61
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr60
				}
			case data[p] >= 9:
				goto tr56
			}
			goto st0
		tr59:
//line lex2.rl:67
			nege = true
			goto st25
		tr60:
//line lex2.rl:67
			cure *= 10
			cure += int(data[p]) - '0'
			goto st25
		st25:
			if p++; p == pe {
				goto _test_eof25
			}
		st_case_25:
//line lex2.go:3073
			switch data[p] {
			case 32:
				goto tr56
			case 44:
				goto tr58
			case 93:
				goto tr61
			}
			switch {
			case data[p] > 13:
				if 48 <= data[p] && data[p] <= 57 {
					goto tr60
				}
			case data[p] >= 9:
				goto tr56
			}
			goto st0
		st26:
			if p++; p == pe {
				goto _test_eof26
			}
		st_case_26:
			if data[p] == 97 {
				goto st27
			}
			goto st0
		st27:
			if p++; p == pe {
				goto _test_eof27
			}
		st_case_27:
			if data[p] == 108 {
				goto st28
			}
			goto st0
		st28:
			if p++; p == pe {
				goto _test_eof28
			}
		st_case_28:
			if data[p] == 115 {
				goto st29
			}
			goto st0
		st29:
			if p++; p == pe {
				goto _test_eof29
			}
		st_case_29:
			if data[p] == 101 {
				goto st30
			}
			goto st0
		st30:
			if p++; p == pe {
				goto _test_eof30
			}
		st_case_30:
			switch data[p] {
			case 32:
				goto st30
			case 44:
				goto tr66
			case 93:
				goto tr67
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st30
			}
			goto st0
		st31:
			if p++; p == pe {
				goto _test_eof31
			}
		st_case_31:
			if data[p] == 117 {
				goto st32
			}
			goto st0
		st32:
			if p++; p == pe {
				goto _test_eof32
			}
		st_case_32:
			if data[p] == 108 {
				goto st33
			}
			goto st0
		st33:
			if p++; p == pe {
				goto _test_eof33
			}
		st_case_33:
			if data[p] == 108 {
				goto st34
			}
			goto st0
		st34:
			if p++; p == pe {
				goto _test_eof34
			}
		st_case_34:
			switch data[p] {
			case 32:
				goto st34
			case 44:
				goto tr71
			case 93:
				goto tr72
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st34
			}
			goto st0
		st35:
			if p++; p == pe {
				goto _test_eof35
			}
		st_case_35:
			if data[p] == 114 {
				goto st36
			}
			goto st0
		st36:
			if p++; p == pe {
				goto _test_eof36
			}
		st_case_36:
			if data[p] == 117 {
				goto st37
			}
			goto st0
		st37:
			if p++; p == pe {
				goto _test_eof37
			}
		st_case_37:
			if data[p] == 101 {
				goto st38
			}
			goto st0
		st38:
			if p++; p == pe {
				goto _test_eof38
			}
		st_case_38:
			switch data[p] {
			case 32:
				goto st38
			case 44:
				goto tr76
			case 93:
				goto tr77
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st38
			}
			goto st0
		st_out:
		_test_eof1:
			cs = 1
			goto _test_eof
		_test_eof2:
			cs = 2
			goto _test_eof
		_test_eof3:
			cs = 3
			goto _test_eof
		_test_eof4:
			cs = 4
			goto _test_eof
		_test_eof39:
			cs = 39
			goto _test_eof
		_test_eof5:
			cs = 5
			goto _test_eof
		_test_eof6:
			cs = 6
			goto _test_eof
		_test_eof7:
			cs = 7
			goto _test_eof
		_test_eof8:
			cs = 8
			goto _test_eof
		_test_eof9:
			cs = 9
			goto _test_eof
		_test_eof10:
			cs = 10
			goto _test_eof
		_test_eof11:
			cs = 11
			goto _test_eof
		_test_eof12:
			cs = 12
			goto _test_eof
		_test_eof13:
			cs = 13
			goto _test_eof
		_test_eof14:
			cs = 14
			goto _test_eof
		_test_eof15:
			cs = 15
			goto _test_eof
		_test_eof16:
			cs = 16
			goto _test_eof
		_test_eof17:
			cs = 17
			goto _test_eof
		_test_eof18:
			cs = 18
			goto _test_eof
		_test_eof19:
			cs = 19
			goto _test_eof
		_test_eof20:
			cs = 20
			goto _test_eof
		_test_eof21:
			cs = 21
			goto _test_eof
		_test_eof22:
			cs = 22
			goto _test_eof
		_test_eof23:
			cs = 23
			goto _test_eof
		_test_eof24:
			cs = 24
			goto _test_eof
		_test_eof25:
			cs = 25
			goto _test_eof
		_test_eof26:
			cs = 26
			goto _test_eof
		_test_eof27:
			cs = 27
			goto _test_eof
		_test_eof28:
			cs = 28
			goto _test_eof
		_test_eof29:
			cs = 29
			goto _test_eof
		_test_eof30:
			cs = 30
			goto _test_eof
		_test_eof31:
			cs = 31
			goto _test_eof
		_test_eof32:
			cs = 32
			goto _test_eof
		_test_eof33:
			cs = 33
			goto _test_eof
		_test_eof34:
			cs = 34
			goto _test_eof
		_test_eof35:
			cs = 35
			goto _test_eof
		_test_eof36:
			cs = 36
			goto _test_eof
		_test_eof37:
			cs = 37
			goto _test_eof
		_test_eof38:
			cs = 38
			goto _test_eof

		_test_eof:
			{
			}
		_out:
			{
			}
		}

//line lex2.rl:301

		goto no
	ret: // jumped to from lexer
		{
			// assert we didn't get ",]"
			if t.tok == tokRBrack && needmore {
				return fmt.Errorf("%w: rejecting ',' before ']'", ErrNoMatch)
			}
			b.rpos += p + 1
			// loop if we saw ',' as our terminator
			if t.tok == tokDatum && t.auxtok == tokComma {
				err := t.output.out.CheckSize()
				if err != nil {
					return err
				}
				needmore = true
				continue
			}
			return nil
		}
	no:
		if p < len(data) {
			return fmt.Errorf("%w couldn't find ']' or datum in list", ErrNoMatch)
		}
		if len(data) >= MaxDatumSize {
			return fmt.Errorf("list item: %w", ErrTooLarge)
		}
		if b.atEOF {
			return fmt.Errorf("%w (unexpected EOF looking for datum or ']')", ErrNoMatch)
		}
		b.fill()
	}
	return b.err
}

//line lex2.go:3314
const list_cont_start int = 1
const list_cont_first_final int = 2
const list_cont_error int = 0

const list_cont_en_main int = 1

//line lex2.rl:342

// lex either tokComma or tokRBrack
func (t *parser) lexMoreList(b *reader) error {
	if !b.assertFill() {
		if b.err != nil {
			return b.err
		}
		return fmt.Errorf("%w (unexpected EOF looking for struct field)", ErrNoMatch)
	}
	for b.err == nil {
		t.tok = tokEOF
		data := b.avail()
		cs, p, pe, eof := 0, 0, len(data), len(data)
		_ = eof

//line lex2.go:3339
		{
			cs = list_cont_start
		}

//line lex2.go:3344
		{
			if p == pe {
				goto _test_eof
			}
			switch cs {
			case 1:
				goto st_case_1
			case 0:
				goto st_case_0
			case 2:
				goto st_case_2
			}
			goto st_out
		st1:
			if p++; p == pe {
				goto _test_eof1
			}
		st_case_1:
			switch data[p] {
			case 32:
				goto st1
			case 44:
				goto tr2
			case 93:
				goto tr3
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st1
			}
			goto st0
		st_case_0:
		st0:
			cs = 0
			goto _out
		tr2:
//line lex2.rl:338
			t.tok = tokComma
//line lex2.rl:340
			b.rpos += p + 1
			return nil
			goto st2
		tr3:
//line lex2.rl:339
			t.tok = tokRBrack
//line lex2.rl:340
			b.rpos += p + 1
			return nil
			goto st2
		st2:
			if p++; p == pe {
				goto _test_eof2
			}
		st_case_2:
//line lex2.go:3396
			goto st0
		st_out:
		_test_eof1:
			cs = 1
			goto _test_eof
		_test_eof2:
			cs = 2
			goto _test_eof

		_test_eof:
			{
			}
		_out:
			{
			}
		}

//line lex2.rl:360

		if p < len(data) {
			return fmt.Errorf("%w (couldn't find ',' or ']' in list)", ErrNoMatch)
		}
		if len(data) >= MaxDatumSize {
			return fmt.Errorf("list whitespace: %w", ErrTooLarge)
		}
		if b.atEOF {
			return fmt.Errorf("%w (unexpected EOF looking for ',' or ']')", ErrNoMatch)
		}
		b.fill()
	}
	return b.err
}

//line lex2.go:3423
const toplevel_start int = 1
const toplevel_first_final int = 2
const toplevel_error int = 0

const toplevel_en_main int = 1

//line lex2.rl:380

func (t *parser) lexToplevel(b *reader) error {
	b.fill()
	for b.err == nil {
		t.tok = tokEOF
		if b.atEOF && b.buffered() == 0 {
			t.tok = tokEOF
			return nil
		}
		data := b.avail()
		cs, p, pe, eof := 0, 0, len(data), len(data)
		_ = eof

//line lex2.go:3446
		{
			cs = toplevel_start
		}

//line lex2.go:3451
		{
			if p == pe {
				goto _test_eof
			}
			switch cs {
			case 1:
				goto st_case_1
			case 0:
				goto st_case_0
			case 2:
				goto st_case_2
			}
			goto st_out
		st1:
			if p++; p == pe {
				goto _test_eof1
			}
		st_case_1:
			switch data[p] {
			case 32:
				goto st1
			case 91:
				goto tr2
			case 123:
				goto tr3
			}
			if 9 <= data[p] && data[p] <= 13 {
				goto st1
			}
			goto st0
		st_case_0:
		st0:
			cs = 0
			goto _out
		tr2:
//line lex2.rl:83
			t.tok = tokLBrack
//line lex2.rl:378
			b.rpos += p + 1
			return nil
			goto st2
		tr3:
//line lex2.rl:82
			t.tok = tokLBrace
//line lex2.rl:378
			b.rpos += p + 1
			return nil
			goto st2
		st2:
			if p++; p == pe {
				goto _test_eof2
			}
		st_case_2:
//line lex2.go:3503
			goto st0
		st_out:
		_test_eof1:
			cs = 1
			goto _test_eof
		_test_eof2:
			cs = 2
			goto _test_eof

		_test_eof:
			{
			}
		_out:
			{
			}
		}

//line lex2.rl:396

		if p < len(data) || b.atEOF {
			return fmt.Errorf("%w (couldn't find '[' or '{'", ErrNoMatch)
		}
		if len(data) >= MaxDatumSize {
			return fmt.Errorf("top-level whitespace: %w", ErrTooLarge)
		}
		b.fill()
	}
	return b.err
}
