// Copyright (C) 2023 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
)

var (
	verbose = false
	inpath  string
	outpath string
)

func main() {
	flag.StringVar(&inpath, "i", "evalbc_amd64.s", "input asm file path")
	flag.StringVar(&outpath, "o", "bytecode_gen.go", "bytecode file path")
	flag.BoolVar(&verbose, "v", false, "be verbose")
	flag.Parse()
	if outpath == "" || inpath == "" {
		flag.Usage()
		return
	}

	opcodes, err := extractOpcodes(inpath)
	check(err)

	err = postprocessOpcodes(opcodes)
	check(err)

	buf := bytes.NewBuffer(nil)
	err = writeDefinitions(opcodes, buf)
	check(err)

	fmt.Printf("Creating %q\n", outpath)
	err = os.WriteFile(outpath, buf.Bytes(), 0644)
	check(err)
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

// --------------------------------------------------

// postprocessOpcodes parses the spec strings and prepare
// data for be written out.
func postprocessOpcodes(opcodes []Opcode) error {
	byopcode := make(map[string]int)
	for i := range opcodes {
		proc := &opcodes[i]
		byopcode[proc.name] = i

		if proc.isVariant() {
			continue
		}
		err := proc.processComments()
		if err != nil {
			return fmt.Errorf("%s: opcode %s: %s", proc.location, proc.name, err)
		} else {
			if verbose {
				fmt.Printf("%-21s: %s", proc.name, proc.spec.name)
				if proc.scratch != "" {
					fmt.Printf(" (scratch: %s)", proc.scratch)
				}
				fmt.Printf("\n")
			}
		}
	}

	err := checkForDuplicates(opcodes)
	if err != nil {
		return err
	}

	return assignBaseSpec(opcodes, byopcode)
}

// checkForDuplicates checks if names of opcodes do not repeat
func checkForDuplicates(opcodes []Opcode) error {
	seen := make(map[string]int)
	for i := range opcodes {
		proc := &opcodes[i]
		if proc.isVariant() {
			continue
		}

		id, ok := seen[proc.spec.name]
		if !ok {
			seen[proc.spec.name] = i
		} else {
			p2 := &opcodes[id]
			return fmt.Errorf("%s: procedure %q already defined for %q (%s)",
				proc.location,
				proc.spec.name,
				p2.name, p2.location)
		}
	}

	return nil
}

// assignBaseSpec completes higher version of opcodes with spec from their base opcodes.
func assignBaseSpec(opcodes []Opcode, byopcode map[string]int) error {
	for i := range opcodes {
		proc := &opcodes[i]
		if !proc.isVariant() {
			continue
		}
		id, ok := byopcode[proc.baseOpcode()]
		if !ok {
			return fmt.Errorf("can't find base name")
		}

		p2 := opcodes[id]
		proc.spec = p2.spec
	}

	return nil
}

const autogenerated = "// Code generated automatically; DO NOT EDIT"

func writeDefinitions(opcodes []Opcode, f io.Writer) error {
	writeln := func(s string, args ...any) {
		fmt.Fprintf(f, s, args...)
		fmt.Fprintf(f, "\n")
	}

	writeln("package vm")
	writeln("")
	writeln(autogenerated)
	writeln("")
	writeln("var generated = [_maxbcop]bcopinfo{")
	for i := range opcodes {
		p := &opcodes[i]

		spec := p.spec.gospec()
		if p.scratch != "" {
			spec += fmt.Sprintf(", scratch: %s", p.scratch)
		}
		writeln("%s: {%s},", p.goconst(), spec)
	}
	writeln("}")

	return nil
}

func panicf(format string, args ...any) {
	panic(fmt.Sprintf(format, args...))
}
