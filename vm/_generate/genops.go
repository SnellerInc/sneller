// Copyright (C) 2022 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
)

type opcode struct {
	name   string
	offset int64

	// if opcode is a different implementation of an existing opcode, base points to that opcode
	base string
}

type oprename struct {
	from, to string
}

func parseAsmFile(ops []opcode, path string) ([]opcode, error) {
	f, err := os.Open(path)
	checkErr(err)
	defer f.Close()

	rd := bufio.NewReader(f)
	re := regexp.MustCompile(`^TEXT bc(?P<op>.*)\(SB\)`)
	ofs := int64(len(ops) * 8)

	scanner := bufio.NewScanner(rd)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "TEXT bc") {
			continue
		}

		if v := re.FindStringSubmatch(line); len(v) > 0 {
			ops = append(ops, opcode{name: v[1], offset: ofs})
			ofs += 8
		}
	}

	return ops, scanner.Err()
}

func parseAsmFiles(paths []string) ([]opcode, []oprename, error) {
	var ops []opcode
	var err error
	for _, path := range paths {
		ops, err = parseAsmFile(ops, path)
		if err != nil {
			return nil, nil, err
		}
	}

	lookup := make(map[string]*opcode)
	for i := range ops {
		lookup[ops[i].name] = &ops[i]
	}

	buildrename := func(suffix string) ([]oprename, error) {
		var rename []oprename
		for i := range ops {
			base, ok := stripSuffix(ops[i].name, suffix)
			if !ok {
				continue
			}

			if _, ok := lookup[base]; !ok {
				return nil, fmt.Errorf("cound not find base opcode for %q", ops[i].name)
			}

			ops[i].base = base

			rename = append(rename, oprename{from: ops[i].base, to: ops[i].name})
		}

		return rename, nil
	}

	rename, err := buildrename("_v2")

	return ops, rename, err
}

const autogenerated = "// Code generated automatically; DO NOT EDIT"

func generateGoFile(name string, ops []opcode, renameLevel2 []oprename) {
	f, err := os.Create(name)
	checkErr(err)
	defer f.Close()

	writeLn(f, "package vm")
	writeLn(f, "")
	writeLn(f, autogenerated)
	writeLn(f, "")
	writeLn(f, "const (")

	for i := range ops {
		if strings.Contains(ops[i].name, "_") {
			writeLn(f, fmt.Sprintf(" //lint:ignore ST1003 opcode naming convention"))
		}

		writeLn(f, fmt.Sprintf("\top%s bcop = %d", ops[i].name, i))
	}

	writeLn(f, fmt.Sprintf("\t%s = %d", "_maxbcop", len(ops)))
	writeLn(f, ")")

	writeLn(f, "")
	writeLn(f, "type opreplace struct {from, to bcop}")
	writeLn(f, "var patchAVX512Level2 []opreplace = []opreplace{")
	for i := range renameLevel2 {
		writeLn(f, fmt.Sprintf("\t{from: op%s, to: op%s},", renameLevel2[i].from, renameLevel2[i].to))
	}
	writeLn(f, "}")
}

func generateAsmFile(name string, ops []opcode) {
	f, err := os.Create(name)
	checkErr(err)
	defer f.Close()

	writeLn(f, `#include "textflag.h"`)
	writeLn(f, "")
	writeLn(f, autogenerated)
	writeLn(f, "")

	const data = "opaddrs"
	const trap = "trap"

	for i := range ops {
		writeLn(f, fmt.Sprintf("DATA %s+0x%03x(SB)/8, $bc%s(SB)", data, ops[i].offset, ops[i].name))
	}

	offset := ops[len(ops)-1].offset
	n := nextPower(len(ops))
	for i := len(ops); i < n; i++ {
		offset += 8
		writeLn(f, fmt.Sprintf("DATA %s+0x%03x(SB)/8, $bc%s(SB)", data, offset, trap))
	}
	offset += 8

	writeLn(f, fmt.Sprintf("GLOBL %s(SB), RODATA|NOPTR, $0x%04x", data, offset))
}

func generateAsmHeader(name string, ops []opcode) {
	f, err := os.Create(name)
	checkErr(err)
	defer f.Close()

	mask := nextPower(len(ops)) - 1

	writeLn(f, autogenerated)
	writeLn(f, fmt.Sprintf("#define OPMASK 0x%03x", mask))
}

func main() {
	ops, rename, err := parseAsmFiles([]string{"evalbc_amd64.s", "bc_eval_math_i64_amd64.h", "bc_eval_math_f64_amd64.h"})
	checkErr(err)

	generateGoFile("ops_gen.go", ops, rename)
	generateAsmFile("ops_gen_amd64.s", ops)
	generateAsmHeader("ops_mask.h", ops)
}

func checkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func writeLn(f *os.File, s string) {
	_, err := f.WriteString(s)
	checkErr(err)
	_, err = f.Write([]byte{'\n'})
	checkErr(err)
}

func nextPower(x int) int {
	n := 1
	for n < x {
		n *= 2
	}

	return n
}

func stripSuffix(s, suff string) (string, bool) {
	s1 := strings.TrimSuffix(s, suff)
	return s1, len(s1) != len(s)
}
