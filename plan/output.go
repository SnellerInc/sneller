// Copyright 2023 Sneller, Inc.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package plan

import (
	"crypto/rand"
	"encoding/base32"
	"fmt"
	"io"
	"io/fs"
	"path"
	"strings"
	"sync"

	"github.com/SnellerInc/sneller/date"
	"github.com/SnellerInc/sneller/db"
	"github.com/SnellerInc/sneller/expr"
	"github.com/SnellerInc/sneller/ion"
	"github.com/SnellerInc/sneller/ion/blockfmt"
	"github.com/SnellerInc/sneller/vm"
)

// uploadSink is a vm.QuerySink that uploads
// data to a single packfile
type uploadSink struct {
	mw    blockfmt.MultiWriter
	store blockfmt.UploadFS
	name  string
	dst   vm.QuerySink
}

// uploadStream is the io.WriteCloser
// returned from uploadSink.Open()
type uploadStream struct {
	ion.Chunker
}

func (up *uploadSink) Open() (io.WriteCloser, error) {
	w, err := up.mw.Open()
	if err != nil {
		return nil, err
	}
	ret := &uploadStream{}
	ret.W = w
	ret.Align = up.mw.InputAlign
	ret.RangeAlign = 100 * ret.Align
	return ret, nil
}

func (up *uploadStream) Close() error {
	err := up.Flush()
	err2 := up.W.(io.Closer).Close()
	if err == nil {
		err = err2
	}
	return err
}

func statdesc(ofs blockfmt.UploadFS, path string, up blockfmt.Uploader, into *blockfmt.Descriptor) error {
	into.Path = path
	into.Size = up.Size()
	type etagger interface {
		ETag() string
	}
	info, err := fs.Stat(ofs, path)
	if err != nil {
		return err
	}
	etag, err := ofs.ETag(path, info)
	if err != nil {
		return err
	}
	if et, ok := up.(etagger); ok {
		into.ETag = et.ETag()
	} else {
		into.ETag = etag
	}
	into.LastModified = date.FromTime(info.ModTime())
	return nil
}

func (up *uploadSink) Close() error {
	err := up.mw.Close()
	if err != nil {
		return err
	}

	var desc blockfmt.Descriptor
	desc.Format = blockfmt.Version
	desc.Trailer = up.mw.Trailer
	err = statdesc(up.store, up.name, up.mw.Output, &desc)
	if err != nil {
		return err
	}
	// fast-path: don't serialize the descriptor
	// if we don't need to
	if is, ok := up.dst.(*indexSink); ok {
		is.rawAppend(&desc)
		return up.dst.Close()
	}

	// write the descriptor
	// as a single output row
	var buf ion.Buffer
	var st ion.Symtab
	blockfmt.WriteDescriptor(&buf, &st, &desc)
	tail := buf.Bytes()
	buf.Set(nil)
	st.Marshal(&buf, true)
	w, err := up.dst.Open()
	if err != nil {
		return err
	}
	_, err = w.Write(append(buf.Bytes(), tail...))
	if err != nil {
		w.Close()
		return err
	}
	err = w.Close()
	if err != nil {
		return err
	}
	return up.dst.Close()
}

// OutputPart is a nonterminal plan node
// that produces one blockfmt.Descriptor row
// for each thread of execution that points
// to an uploaded file containing all the data
// written into this node.
type OutputPart struct {
	Nonterminal
	Basename string
}

func uuid() string {
	var buf [16]byte
	_, err := rand.Read(buf[:])
	if err != nil {
		// crypto random source is busted?
		panic(err)
	}
	// remove the trailing padding; it is deterministic
	return strings.TrimSuffix(base32.StdEncoding.EncodeToString(buf[:]), "======")
}

func (o *OutputPart) exec(dst vm.QuerySink, src *Input, ep *ExecParams) error {
	if o.Basename == "" {
		return fmt.Errorf("OutputPart: basename not set")
	}
	store, ok := ep.FS.(UploadFS)
	if !ok {
		return fmt.Errorf("OutputPart: upload not supported")
	}
	name := path.Join(o.Basename, "packed-"+uuid())
	up, err := store.Create(name)
	if err != nil {
		return err
	}
	us := &uploadSink{
		store: store,
		name:  name,
		dst:   dst,
	}
	us.mw.Output = up
	us.mw.Algo = "zstd" // FIXME: grab this from elsewhere
	us.mw.InputAlign = 1 << 20
	return o.From.exec(us, src, ep)
}

func (o *OutputPart) encode(dst *ion.Buffer, st *ion.Symtab, _ *ExecParams) error {
	dst.BeginStruct(-1)
	settype("outpart", dst, st)
	dst.BeginField(st.Intern("basename"))
	dst.WriteString(o.Basename)
	dst.EndStruct()
	return nil
}

func (o *OutputPart) SetField(f ion.Field) error {
	switch f.Label {
	case "basename":
		basename, err := f.String()
		if err != nil {
			return err
		}
		o.Basename = basename
	default:
		return errUnexpectedField
	}
	return nil
}

func (o *OutputPart) String() string {
	return "OUTPUT PART " + o.Basename
}

// OutputIndex is a nonterminal plan node
// that accepts rows from OutputPart and collects
// them into an Index object. OutputIndex writes
// one output row containing the autogenerated
// table name.
type OutputIndex struct {
	Nonterminal
	DB, Table string
	Basename  string
	Key       *blockfmt.Key
}

// indexSink is a vm.QuerySink that collects
// the results of OutputPart and writes an Index
// on the final Close and returns the autogenerated
// table name as a single output record
type indexSink struct {
	key     *blockfmt.Key
	store   UploadFS
	lock    sync.Mutex
	db, tbl string
	idx     *blockfmt.Index
	dst     vm.QuerySink
	closed  bool
}

type indexWriter struct {
	syms   ion.Symtab
	parent *indexSink
}

func (is *indexSink) rawAppend(desc *blockfmt.Descriptor) {
	is.lock.Lock()
	defer is.lock.Unlock()
	is.idx.Inline = append(is.idx.Inline, *desc)
}

func (i *indexWriter) Write(p []byte) (int, error) {
	var dat ion.Datum
	var err error
	n := len(p)
	if ion.IsBVM(p) || ion.TypeOf(p) == ion.AnnotationType {
		p, err = i.syms.Unmarshal(p)
		if err != nil {
			return 0, err
		}
	}
	for len(p) > 0 {
		dat, p, err = ion.ReadDatum(&i.syms, p)
		if err != nil {
			return n - len(p), err
		}
		desc, err := blockfmt.ReadDescriptor(dat)
		if err != nil {
			return n - len(p), err
		}
		i.parent.rawAppend(desc)
	}
	return n, nil
}

func (i *indexWriter) Close() error { return nil }

func (is *indexSink) Open() (io.WriteCloser, error) {
	return &indexWriter{
		parent: is,
	}, nil
}

func (is *indexSink) Close() error {
	if is.closed {
		return nil
	}
	is.closed = true
	idxmem, err := blockfmt.Sign(is.key, is.idx)
	if err != nil {
		return err
	}
	idxpath := db.IndexPath(is.db, is.tbl)
	_, err = is.store.WriteFile(idxpath, idxmem)
	if err != nil {
		return err
	}
	var buf ion.Buffer
	var st ion.Symtab
	tabsym := st.Intern("table")
	st.Marshal(&buf, true)
	buf.BeginStruct(-1)
	buf.BeginField(tabsym)
	buf.WriteString(expr.ToString(expr.MakePath([]string{is.db, is.tbl})))
	buf.EndStruct()
	w, err := is.dst.Open()
	if err != nil {
		return err
	}
	_, err = w.Write(buf.Bytes())
	if err != nil {
		w.Close()
		return err
	}
	return w.Close()
}

func (o *OutputIndex) exec(dst vm.QuerySink, src *Input, ep *ExecParams) error {
	if o.Basename == "" {
		return fmt.Errorf("OutputIndex: basename not set")
	} else if o.Key == nil {
		return fmt.Errorf("OutputIndex: key not set")
	}
	store, ok := ep.FS.(UploadFS)
	if !ok {
		return fmt.Errorf("OutputPart: upload not supported")
	}
	tbl := &expr.Dot{
		Inner: expr.Ident(o.DB),
		Field: o.Table + "-" + uuid(),
	}
	idx := &blockfmt.Index{
		Name: tbl.Field,
		Algo: "zstd",
	}
	is := &indexSink{
		key:   o.Key,
		store: store,
		db:    o.DB,
		tbl:   tbl.Field,
		idx:   idx,
		dst:   dst,
	}
	return o.From.exec(is, src, ep)
}

func (o *OutputIndex) SetField(f ion.Field) error {
	var err error
	switch f.Label {
	case "db":
		o.DB, err = f.String()
	case "table":
		o.Table, err = f.String()
	case "basename":
		o.Basename, err = f.String()
	case "key":
		inner, err := f.BlobShared()
		if err != nil {
			return err
		}
		if len(inner) != blockfmt.KeyLength {
			return fmt.Errorf("invalid key length: %d", len(inner))
		}
		o.Key = new(blockfmt.Key)
		copy(o.Key[:], inner)

	default:
		return errUnexpectedField
	}
	return err
}

func (o *OutputIndex) encode(dst *ion.Buffer, st *ion.Symtab, ep *ExecParams) error {
	dst.BeginStruct(-1)
	settype("outidx", dst, st)
	dst.BeginField(st.Intern("db"))
	dst.WriteString(o.DB)
	dst.BeginField(st.Intern("table"))
	dst.WriteString(o.Table)
	dst.BeginField(st.Intern("basename"))
	dst.WriteString(o.Basename)
	dst.BeginField(st.Intern("key"))
	dst.WriteBlob(o.Key[:])
	dst.EndStruct()
	return nil
}

func (o *OutputIndex) String() string {
	e := expr.MakePath([]string{o.DB, o.Table})
	return fmt.Sprintf("OUTPUT INDEX %s AT %s", expr.ToString(e), o.Basename)
}
